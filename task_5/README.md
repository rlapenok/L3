# Система управления задачами с использованием Axum, PostgreSQL, Redis и Docker (L3.8)

Система предназанчена для создания задач, получение уведомлений о выполненых/невыполненных задач, а так же выполнение задач
Система состоиит из трех сервисов: TaskService(отвечает за создании задач), TaskExecutor( отвечает за выполнение задач), TaskNotifier(отвечает за получение уведомлений о состоянии задач, а так же для получения уведомлений).
В качестве очереди сообщений используется Redis (Stream), для хранения задач используется Postgres. Все сервисы уложены в DockerFile. Весь flow контейнеров находится в docker-compose файле. Так же используется tracing с отправкой трейсов в Tempo(Grafana), а так же вывод в консоль


## 1. Запуск приложения 

```bash
  docker-compose up -d
```
## 2. API приложения 
#### Cоздание новой задачи  
```http
  POST /tasks
  Content-Type: application/json
{
    "description":"Hello"
}
```
#### Получение уведомлений
```http
  GET /notifications/?type={type}
  type=completed или non_completed
```

#### Изменение статуса задачи (данный запрос выполняет TaskExecutor, но есть возможность вручную изменять статус задачи)
```http
  POST /tasks/:id/complete
  Content-Type: application/json
  "tasks": [

{

"operation": "UPDATE",

"id": "fb431409-6e4f-4021-8524-f9c1641c6835",

"description": "Hello",

"created_at": "2024-10-31T12:56:08.089861Z",

"completed_at": "2024-10-31T12:56:08.301260Z",

"trace_id": "53f6143e12f8e0ba72f1a53a8f886067",

"span_id": "be13f0aaa9d258dc"

}

]
```

## 3. Принципиальное описание работы TaskService,TaskExecutor, TaskNotifier 

### 3.1 TaskService
#### 3.1.1 Запуск
```bash
  task_service -a localhost:8080 -p config.toml
```
#### 3.1.2 Остановка
```bash
	  ctrl+C
  ```
#### 3.1.3 Принцип работы 
Поступающие запросы создают новую задачу с `id`, `created_at`,`completed_at`. Далее задача сохраняется  в `Postgres` после чего пользователю отдается ответ с `id` задачи. В другом потоке крутится `слушатель` изменений в таблице (`inserts`,`updates` - добавление, изменение статуса задачи соответственно), который отправляет по каналу в другой поток эти изменения  `отправителю в redis stream` , который в свою очередь отправляет задачи в 2 разных очереди `(inserts,updates)`.В результате этих изменений формируется trace, который выводится в консоль а также отправляется в `Tempo`.


### 3.2 TaskExecutor
#### 3.2.1 Запуск
```bash
  task_executor  -p config.toml
```
#### 3.2.2 Остановка
```bash
	  ctrl+C
  ```
#### 3.2.3 Принцип работы 
Происходит прослушивание происходящих изменений в очереди сообщений `inserts`, после чего эти изменения отправляются к `Executor` по каналу. `Executor` в свою очередь читает эти изменения и выполняет работу (предусмотрена конфигурация количества `worker`;в данной реализации работа заключалась в остановке потока выполнения на определенной время, а затем отправка `TaskService` информации о выполнении задачи). При завершении работы происходит сохранение последнего обработанного  сообщения из очереди и сохранение в файл. Так же при запуске сервиса происходит считывание этого файла и "запуск в работу" сообщений, которые были добавлены в очередь. Так же формируется `trace` с добавлением в `Tempo`. 


### 3.3 TaskNotifier
#### 3.3.1 Запуск
```bash
    task_notifier -a localhost:8080 -p config.toml
```
#### 3.3.2 Остановка
```bash
	  ctrl+C
  ```
#### 3.3.3 Принцип работы 
На поступающий запрос происходит чтение уведомлений о добавлении/изменении статуса задачи. В 2 отдельных потоках происходит чтение сообщений из каналов `inserts` и `updates`, после чего они отправляются по каналу. В данном канале происходит считывание  при необходимости (поступление запроса). Так же формируется `trace` с добавлением в `Tempo`. 


P.S. Скрины трейсов приложены